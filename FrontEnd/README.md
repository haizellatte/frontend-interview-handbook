# FrontEnd

- [RESTful API에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#1-restful-api%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [객체 지향 프로그래밍이란 무엇인가요?](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#1-restful-api%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [프로세스와 스레드는 각자 무엇이며, 어떤 차이가 있나요?](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%8A%94-%EA%B0%81%EC%9E%90-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94)
- [자바스크립트는 싱글 스레드 언어로 알려져있는데, 싱글 스레드와 멀티 스레드의 차이점은 무엇이며, 각 장단점은 무엇인지 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%96%B8%EC%96%B4%EB%A1%9C-%EC%95%8C%EB%A0%A4%EC%A0%B8%EC%9E%88%EB%8A%94%EB%8D%B0-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EA%B0%81-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [브라우저의 렌더링 과정에 대하여 설명해 주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#5-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)
- [주소창에 google.com을 입력하면 일어나는 일을 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#6-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-googlecom%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [DNS에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#6-1-dns%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [크로스 브라우징에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#7-%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [ES6 이상의 버전으로 작성한 코드를 브라우저에서 인식하지 못한다면 어떻게 해결하실건가요?](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#7-1-es6-%EC%9D%B4%EC%83%81%EC%9D%98-%EB%B2%84%EC%A0%84%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EC%9D%B8%EC%8B%9D%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C%EB%8B%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EC%8B%A4%EA%B1%B4%EA%B0%80%EC%9A%94)
- [SEO에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#8-seo%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [TCP와 UDP의 차이점에 대해 설명해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#9-tcp%EC%99%80-udp%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [프레임워크와 라이브러리의 차이점에 대해 말씀해주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#10-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%99%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EB%A7%90%EC%94%80%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)
- [UI와 UX에 대해 설명해 주세요.](https://github.com/sienna0715/frontend-interview-handbook/blob/main/FrontEnd/README.md#11-ui%EC%99%80-ux%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)
- [CORS가 무엇이며, 해결하기 위한 방법에 대해 설명해 주세요.](https://github.com/sienna0715/frontend-interview-handbook/tree/main/FrontEnd#12-cors%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

---

<br/>

## 1. RESTful API에 대해 설명해주세요.

### 1️⃣ REST란

우선 RESTful API의 REST는 “Representational State Transfer”의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미합니다.
즉, HTTP URI를 통해 자원(Resource)을 명시하고, HTTP Method를 통해 해당 URI에 대한 CRUD Operation을 적용하는 것입니다.

> **CRUD Operation란?** <br/>
> Create, Read, Update, Delete를 통틀어 일컫는 말이다. <br/><br/>
> Create: 데이터 생성(POST) <br/>
> Read: 데이터 조회(GET) <br/>
> Update: 데이터 수정(PUT, PATCH) <br/>
> Delete: 데이터 삭제(DELETE)

<br/>

### 2️⃣ REST 구성과 특징

- 자원(RESOURCE) -> URI
- 행위(Verb) -> HTTP METHOD
- 표현(Representations)

1. Uniform (유니폼 인터페이스) <br/>
   : 4가지 인터페이스로 한정지어서 해당하는 Resource를 접근하도록 만든 아키텍처 스타일
2. Stateless (무상태성) <br/>
   : 상태정보를 따로 저장하고 관리하지 않는다.
3. Cacheable (캐시 가능) <br/>
   : HTTP가 가진 캐싱 기능이 적용 가능
4. Self-descriptiveness (자체 표현 구조) <br/>
   : REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다
5. Client - Server 구조 <br/>
   : 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 준다.
6. 계층형 구조 <br/>
   : 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있다.
   <br/><br/>
   **HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다!!!**

<br/>

### 3️⃣ REST API란

방금 설명한 REST의 원리를 따르는 API를 말하는 것으로 REST API의 설계 규칙을 올바르게 지킨 시스템을 "**RESTful하다**"라고 합니다.

그럼 어떤 규칙을 지켜야 하는지 알아보도록 하겠습니다. <br/><br/>

#### ‼️ REST API 중심 규칙

1. URI는 정보의 자원을 표현해야 한다.
2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현
   > DELETE /members/1

#### ‼️ URI 설계 시 주의할 점

1. URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다.

   > Bad Example http://khj93.com/Running/ <br/>
   > Good Example http://khj93.com/run/

2. 마지막에 슬래시(/)를 포함하지 않는다.

   > Bad Example http://khj93.com/test/ <br/>
   > Good Example http://khj93.com/test

3. 언더바 대신 하이폰을 사용한다.

   > Bad Example http://khj93.com/test_blog <br/>
   > Good Example http://khj93.com/test-blog

4. 파일확장자는 URI에 포함하지 않는다.

   > Bad Example http://khj93.com/photo.jpg <br/>
   > Good Example http://khj93.com/photo

5. URI에 행위(HTTP Method)나 동사 표현이 들어가면 안 된다.
   > Bad Example http://khj93.com/members/delete/1 <br/>
   > Bad Example http://khj93.com/members/show/1 <br/>
   > Good Example http://khj93.com/members/1

<br/>
이렇듯 REST API는 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능하다는 것 입니다.
<br/><br/>

cf. [RESTful API란 무엇입니까?](https://aws.amazon.com/ko/what-is/restful-api/)
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 2. 객체 지향 프로그래밍(OOP)란 무엇인가요?

"Object Oriented Programming"의 약자로 객체 개념에 기반한 프로그래밍 패러다임의 일종으로, 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법을 말합니다.
<br/><br/>

그럼 객체 지향 프로그래밍의 핵심 4가지에 대해 얘기해보도록 하겠습니다.

### Encapsulation (캡슐화)

연관 있는 데이터와 함수를 오브젝트에 담아두고, 외부에서 보일 필요가 없는 데이터를 캡슐화하는 것을 맓합니다.

- 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것 (변수와 함수를 하나로 묶는 것을 뜻함)
- 낮은 결합도를 유지할 수 있도록 설계하는 것

어떤 데이터를 묶을 것인지, 어떤 데이터를 외부에 보여줄 건지 혹은 볼 수 없는지를 만들어내는 것이 OOP의 첫걸음입니다.
<br/><br/>

### Abstraction (추상화)

내부의 복잡한 기능을, 외부에서 어떤 형태로, 공통적으로 어떻게 이 클래스를 이용하게 할 것인가를 고민하는 것을 추상화라고 합니다.

- 객체에서 공통된 속성과 행위를 추출 하는 것
- 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
- 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것
  <br/><br/>

### Inheritance (상속)

정의해둔 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것을 말합니다. 즉, 재사용할 수 있게 해줍니다.

- 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능
  <br/><br/>

### Polymorphism (다형성)

poly = many, morphi = form이라 하여 해석하면, '다양한 형태'를 의미하듯, 다형성은 공통된 함수(클래스)로 만들어진 객체(인스턴스)에 접근할 수 있습니다. 클래스 내부에 같은 이름의 행위를 여러개 정의하거나 상위 클래스의 행위를 하위 클래스에서 재정의하여 사용할 수 있기 때문에 다형성이라는 특징을 갖게 됩니다.

- 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것
- 어떠한 요소에 여러 개념을 넣어 놓는 것

<br/><br/>
이런 특징 때문에 객체 지향 프로그래밍은 클래스 단위로 모듈화하여 업무 분담이 편리하고 이 때문에 대규모 소프트웨어 개발에 적합합니다. 또한 "객체"라는 특징을 통해 데이터 코드 별로 묶을 수 있어 해당 객체만 이해한다면 수정이 가능하기 때문에 유지보수성이 좋고 상속을 통해 확장하기 좋으며 재사용 측면에서도 좋습니다. <br/> 그러나 객체 수에 따라 용량이 커진다는 단점이 있습니다.

<br/>
객체지향 프로그래밍을 지원하는 언어로는 C++ , C# , Java , Python , JavaScript , Ruby , Swift 등이 있습니다. 
<br/><br/>

cf. [객체지향 프로그래밍이란?](https://jongminfire.dev/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 3. 프로세스와 스레드는 각자 무엇이며, 어떤 차이가 있나요?

### ✍️ 프로세스와 스레드, 한줄 정리

| 프로그램(Program)                         | 프로세스 (Process)                         | 스레드 (Thread)                                      |
| ----------------------------------------- | ------------------------------------------ | ---------------------------------------------------- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 운영체제로부터 자원을 할당받은 작업의 단위 | 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 |

### 🖥️ 프로그램(Progam)

- `어떤 작업을 위해 실행할 수 있는 파일`로, 작성한 코드를 빌드하여 생성되는 결과물을 의미합니다.
- 프로그램은 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태입니다.
- 따라서 프로그램을 실행하기 위해서는 Memory 자원을 할당 받아야 하는테, 이때 자원을 할당받아 실행되는 프로그램을 프로세스라고 합니다.

### 🖥️ 프로세스 (Process)

<img src="https://velog.velcdn.com/images/haizel/post/c06605bc-afe8-4309-b5f8-722cda7303ea/image.png" width="500" />

- `컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램` 으로, 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)를 말합니다.
- 즉 운영체제로부터 시스템 자원을 할당받은 작업의 단위로, 동적인 개념으로는 `실행된 프로그램`을 의미합니다.

#### 특징

<img src="https://velog.velcdn.com/images/haizel/post/a8878d85-c701-4148-b6d8-33a9d2738371/image.png" width="500" />

1. 프로세스는 각각 독립된 메모리 영역 (Code, Data, Stack, Heap의 구조)를 할당 받습니다.
2. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다.
3. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없습니다.
4. 한 프로세스가 다른 프로세스 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process-Communication)을 사용해야 합니다.
   - e.g. 파이프, 파일, 소켓 등을 이용한 통신 방법

<br />

### 🖥️ 스레드(Thread)

- `프로세스 내에서 실행되는 여러 흐름의 단위`로, **프로세스의 특정한 수행 경로**를 말합니다.
- 즉 프로세스가 할당받은 자원을 이용한 실행의 단위입니다.

<br />

쉽게 설명하자면, 크롬 브라우저를 실행하면 하나의 프로세스가 생성됩니다.
이때 브라우저에서 파일을 다운 받고 노래를 들으며 온라인 쇼핑을 한다면 각 작업마다 스레드가 형성됩니다. 즉, 하나의 프로세스 안에서 여러 작업의 흐름이 동시에 진행되기 때문에 가능한 일입니다.

<img src="https://velog.velcdn.com/images/haizel/post/0a64869f-615b-4f99-b4ca-6d797cd53d38/image.png" width="700" />

여기서 각 일련의 작업 흐름들을 **스레드**라고 하며, 스레드가 여러 개라면 **멀티(다중) 스레드**라고 합니다.

#### 특징

<img src="https://velog.velcdn.com/images/haizel/post/0ee25928-42e8-4745-8fd9-73e9ed1a2a1d/image.png" width="500" />

1. 스레드는 프로세스 내에서 각 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유합니다.
2. 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 프로세스 내 스레드끼리 공유하며 실행됩니다.
3. 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
4. 각 스레드는 별도 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있습니다.
5. 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling Thread)도 해당 변경 결과를 즉시 볼 수 있습니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 4. 자바스크립트는 싱글 스레드 언어로 알려져있는데, 싱글 스레드와 멀티 스레드의 차이점은 무엇이며, 각 장단점은 무엇인지 설명해주세요.

### 🙎‍♀️ 싱글스레드(Single thread)

<img src="https://velog.velcdn.com/images/haizel/post/4e2a729d-113e-40e8-a17f-f09c24d612ff/image.png" width="300" height="400" />
하나의 프로세스에 오직 하나의 스레드로만 실행되며, 따라서 하나의 레지스터와 스택으로 표현이 가능합니다.

순차 실행 방식으로, 앞선 동작이 먼저 수행되야만 이후 동작을 수행할 수 있습니다.

#### 👍 장점

1. **프로그래밍 난이도가 쉽고, CPU와 메모리 사용이 적습니다.**

단일 스레드로, 비용이 적게 소요됩니다.

2. **컨텍스트 스위칭(Context Switching, 문맥 교환)을 요구하지 않습니다.**

문맥 교환은 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용을 필요로 합니다.

3. **자원 접근에 대한 동기화를 신경쓰지 않아도 됩니다.**

여러 개의 스레드가 프로세스의 자원을 공유할 경우, 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근을 제어해야 합니다. 쉽게 말해 모든 스레드가 일정 자원에 동시에 접근하거나, 똑같은 작업을 실행하려고 하면 에러가 발생하거나 원하는 값이 나오지 않습니다. 때문에 스레드들이 동시에 같은 자원에 접근하지 못하도록 제어해주어야합니다. 이때 해당 많은 비용을 발생시킵니다.

#### 👎 단점

1. **여러 개의 CPU를 활용하지 못합니다.**

싱글스레드에서 프로세서를 최대한 활용하기 위해선 Cluster 모듈을 사용하거나 외부에서 여러 개의 프로그램 인스턴스를 실행시키는 방법을 사용해야합니다. 뿐만 아니라 다수의 프로그램 인트턴스가 어떻게 상태를 공유할 것인지도 고려해야 합니다.

2. **연산량이 많은 작업을 하는 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있습니다.**

많은 연산 시간이 필요한 작업의 경우, 작업이 완료되어야 다음 작업을 진행할 수 있기에 유저 경험에 좋지 않은 영향을 줍니다.

3. **싱글 스레드 모델은 에러 처리를 못하는 경우 중단됩니다.**

반면 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복합니다.

<br />

### 👨‍👩‍👧‍👦 **멀티 스레드 (Multi thread)**

<img src="https://velog.velcdn.com/images/haizel/post/43689b9a-2245-4cc7-9822-8f9bc2f64455/image.png" width="300" height="300" />

멀티 스레드는 CPU의 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술로, 컨텍스트 스위칭을 통해서 이뤄집니다.

메인 스레드 외의 추가적인 스레드를 이용하여 병렬적으로 작업을 처리한다는 특징이 있습니다.

> 💡 **컨텍스트 스위칭(Context Switching)이란?**
>
> - CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 말합니다.
> - 구체적으로, 동작 중인 프로세스가 대기 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말합니다.

#### 👍 장점

1. **응답성**

프로그램의 일부분(스레드 중 하나)이 중단되거나, 긴 작업을 수행하더라도 프로그램의 수행이 계속 되어 사용자에 대한 응답성이 증가합니다. 즉 에러 발생 시 즉시 새로운 스레드를 생성해 극복합니다. 단 이 때 새 스레드 생성과 놀고 있는 스체드 처리에 따른 비용이 발생할 수 있습니다.

2. **경제성**

프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어듭니다. 또한 스레드간 컨텍스트 스위칭은 캐시 메모리를 비울 필요가 없기 때문에 더 빠른 속도를 보장합니다.

3. **멀티 프로세서의 활용**

다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가합니다.

#### 👎 단점

1. **컨텍스트 스위칭, 동기화 등으로 오히려 단일 스레드보다 더 많은 시간이 소요될 수 있습니다.**

2. **동기화가 필수적입니다.**

스레드는 데이터와 힙 영역을 공유하기 때문에, 공유하는 자원에 동시에 접근하는 경우, 다른 스레드에서 사용중인 변수나 자료구조에 접근해 엉뚱한 값을 읽어오거나 수정할 수 있습니다. 따라서 동기화가 필수적입니다.

3. **멀티 스레딩을 위해서는 운영체제의 지원이 필요합니다.**

4. **프로그래밍 난이도가 높고, 스레드 수만큼 많은 자원을 필요로 합니다.**

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 5. 브라우저의 렌더링 과정에 대하여 설명해 주세요.

![image](https://github.com/sienna0715/frontend-interview-handbook/assets/115691844/02a48707-739d-412c-bec0-50dd6eef509f)

<br/>

1. 사용자가 브라우저를 통해 웹 사이트에 접속합니다.
2. Resource Downloading : 브라우저는 서버로부터 HTML, CSS, JavaScript와 같은 필요한 리소스를 웹사이트에 다운 받습니다.
3. HTML DOM Tree 구축 : 렌더링 엔진은 전달받은 HTML 문서를 파싱(parsing)해 DOM(Document Object Model, 문서 객체 모델) 트리 형성합니다.
4. CSSOM Tree 구축 : 이어서 다운 받은 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱(parsing)해 CSSOM Tree 형성합니다.
5. Render Tree 구축 : 만든 DOM 트리와 CSSOM 트리를 결합합니다.
6. Rayout : 각 요소를 어디에 배치할 지 결정합니다.
7. Paint : 레이아웃 과정이 끝나면 UI 백엔드에서 Render 트리를 화면에 그리기 시작하는 과정입니다.

> 주의 : HTML문서를 파싱하는 도중에 Javascript를 만나면 하던 일을 멈추고 Javascript 먼저 읽습니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 6. 주소창에 google.com을 입력하면 일어나는 일을 설명해주세요.

<p align="center"><img src="https://user-images.githubusercontent.com/115691844/241798832-f26f160b-cf66-4cf3-89e6-7ccbe77e5bb0.png" width="500"></p>

<br/>

1. 사용자가 브라우저 검색창에 www.google.com 입력합니다.
2. 브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인 주소와 대응하는 IP주소를 확인합니다.
3. DNS가 브라우저에게 찾는 사이트의 IP주소를 응답합니다.
4. 브라우저가 서버에게 IP주소를 이용하여 데이터를 요청합니다.
5. 서버가 요청 받은 데이터를 처리합니다.
6. 서버는 브라우저에게 데이터 처리 결과를 응답합니다.
7. 브라우저는 화면에 결과를 출력합니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 6-1. DNS에 대해 설명해주세요.

도메인 이름 시스템 서버(Domain NAme System Servers)는 URL들의 이름과 IP주소를 저장하고 있는 데이터베이스로, 웹사이트를 위한 주소록입니다. 숫자로 된 IP 주소 대신 사용자가 사용하기 편리하도록 주소를 매핑해 주는 역할을 합니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 7. 크로스 브라우징에 대해 설명해주세요.

### 🖥️ 크로스 브라우징(Cross Browsing)이란?

> _Cross Browsing이란_ 표준 웹 기술을 채용하여 다른 기종 혹은 플랫폼에 따라 달리 구현되는 기술을 **비슷하게** 만들어 웹 페이지를 제작하는 기법을 말하는 것이다.
>
> 한국소프트웨어진흥원 공개 SW지원센터 발간한 ‘Cross Browsing 가이드’ 중

크로스 브라우징은 W3C(World Wide Web Consortium)에서 채택한 **표준 웹 기술**을 적용해 **어떤 브라우저 환경**에서도 **정상적으로 작동**하는 웹 페이지를 만드는 방법론을 말합니다.

쉽게 설명하면, 크롬에서 이용할 수 있는 사이트가 익스플로러나 오페라 등 다른 브라우저에서도 정상적으로 사이트를 이용할 수 있게 만드는 기술입니다.

크로스 브라우징을 고려하지 않으면 HTML, CSS, JS 등 코드가 원하는대로 작동되지 않을 수 있어, 각 브라우저의 렌더링 엔진에 따른 크로스 브라우징 설정을 해주어야 합니다.

### ⚠️ 크로스 브라우징은 바벨을 통해 이루어진다.

> 바벨(Babel)은 대표적인 트렌스파일러로, 특정 언어로 작성된 코드를 다른 언어로 변환시키는 역할을 수행합니다. 입력과 출력이 모두 자바스크립트 코드인 컴파일러입니다.

바벨은 1) 최신 문법(ES5 이후)으로 작성된 코드를 ES5버전의 코드로 바꿔주고, 2) TypeScript, JSX 등 다른 언어로 작성된 코드들이 모든 브라우저에서 동작하도록 호환성을 지원합니다.

### ⚠️ 크로스 브라우징은 동일성이 아니라 `동등성`을 의미합니다.

‘크로스 브라우징’은 모든 브라우저에서 화면이 동일하게 표시되는 것이 아닌 `동등한 수준의 정보, 기능이 제공`되는 것을 의미합니다.

크롬, 사파리 등 각 웹 브라우저는 각기 다른 속성과 렌더링엔진으로 이루어져 있기 때문에, 동일한 웹사이트에 접속하더라도 브라우저 종류에 따라 다르게 보일 수 있습니다. 즉, ‘모든 브라우저에서 동일한 화면을 보여주는 것’은 현실적으로 어려움이 있습니다.

대신 ‘크로스 브라우징’을 통해 최대한 다양한 브라우저에서 제작자가 의도한 내용을 이상없이 동작하도록 해주는 것입니다.

### ⚠️ 렌더링 엔진이란 무엇인가?

> 웹 렌더링 엔진(Web Rendering Engine) 또는 웹 브라우저 엔진(Web Browser Engine) 또는 웹 레이아웃 엔진(Web Layout Engine)이라고도 불립니다.

페이지를 렌더할 때 실질적으로 페이지를 작업해주는 브라우저 엔진을 의미합니다.
사용되는 브라우저 버전 혹은 지원 회사에 따라 렌더링 엔진은 다르게 사용됩니다.

| 브라우저            | 렌더링 엔진 | vendor prefix |
| ------------------- | ----------- | ------------- |
| 모질라, 파이어폭스  | Gecko       | -moz-         |
| 구글(크롬), 오페라  | Blink       | -webkit-, -o- |
| 사파리              | Webkit      | -webkit-      |
| 익스플로러          | Trident     | -ms-          |
| 마이크로소프트 엣지 | EdgeHTML    | -ms-          |

### ⚠️ **벤더 프리픽스(Vendor Prefix)란?**

CSS 호환성을 위해 웹 브라우저 별로 전용 CSS 속성을 부여할 수 있도록 제공되는 표준의 CSS 속성 기술 방법입니다.
같은 CSS 속성을 브라우저 종류에 따라 다르게 적용되도록 별도의 접두어를 속성명 앞에 붙여 해당 브라우저가 인식하고 사용할 수 있도록 합니다.

```jsx
<style>

    .button {

        background: red;          <!-- gradient 속성을 지원하지 않는 모든 브라우저를 위한 코드 -->

        background: -webkit-linear-gradient(red, yellow); <!-- 크롬과 사파리 4.0 이상을 위한 코드 -->

        background: -moz-linear-gradient(red, yellow);    <!-- 파이어폭스 3.6 이상을 위한 코드 -->

        background: -ms-linear-gradient(red, yellow);     <!-- 익스플로러 10.0 이상을 위한 코드 -->

        background: -o-linear-gradient(red, yellow);      <!-- 오페라 10.0 이상을 위한 코드 -->

        background: linear-gradient(red, yellow);         <!-- CSS 표준 문법 코드 -->

    }

</style>
```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 7-1. ES6 이상의 버전으로 작성한 코드를 브라우저에서 인식하지 못한다면 어떻게 해결하실건가요?

> 최신 자바스크립트의 호환성 문제를 해결하는 방법을 묻는 질문

브라우저 별로 렌더링 엔진 등의 차이가 있기 때문에 브라우저 호환성 이슈가 발생하는데, 이러한 차이를 최소화해 런타임 환경에 맞게 최적화하는 작업을 크로스 브라우징이라고 합니다. 그리고 이러한 크로스 브라우징 이슈를 해결할 수 있는 툴이 바로 바벨입니다.

### 바벨(Babel)

바벨은 ES6+ 버전의 자바스크립트나 타입스트립트, JSX 등 다른언어로 작성된 코드를 다른 언어로 변환시키는 역할을 수행하여, 모든 브라우저에서 동작할 수 있도록 호환성을 보장합니다.

즉 바벨은 추상화 수준을 유지한 채로 코드를 변화시키는 트랜스파일러의 역할을 합니다. 바벨을 통해 ES6+ 버전의 자바스크립트 코드를 하위 버전으로 변환해 상위 버전을 지원하지 않는 브라우저나 다른 언어를 사용하는 브라우저에서도 기능이 동등하게 동작할 수 있게 합니다.
<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 8. SEO에 대해 설명해주세요.

우선, SEO는 Search Engine optimization의 줄임말로, 쉽게 말해 검색 엔진 최적화를 의미합니다. 우리가 궁금한게 생겨 구글이나 네이버에 검색을 했을 때, 수많은 검색 결과 중 가장 상위에 노출된 페이지들에 접속한 경험이 다들 있을 것 입니다. 이렇듯 검색 결과 페이지에서 노출도를 높이는 작업을 SEO라고 합니다.
<br /><br />
간략하게 먼저 설명하자면 구글이나 네이버의 검색 엔진이 쉽게 이해할 수 있는 형태로 웹페이지를 구성하는 과정입니다.

검색 결과 첫 페이지에서는 크게 두 가지로 나눠볼 수 있습니다.

- 자연 검색 (Organic Search)
- PPC (Pay-per-click)

> pay-per-click(PPC)은 의역하면 '클릭당 지불'이라는 의미로 검색 엔진, 웹사이트, 블로그 등에서 쓰이는 것인 바, 사용자가 광고를 클릭해서 광고주의 웹사이트로 이동하였을 경우에만 광고주가 대금을 지불하는 방식의 광고 모델이다. 키워드 광고의 일종이다. <br /> 코스트 퍼 클릭(Cost Per Click, 줄여서 CPC),혹은 페이 퍼 십(Pay per Ship)이라고도 일컫는다.

<br />

"그냥 쉽고 확실하게 검색 광고 방식을 사용해 상위로 올리는 게 더 좋은거 아닌가?" 라고 생각할 수도 있을 것입니다. 아래 그래프를 봅시다!
<br /><br />

<p align="center"><img src="https://images.sparktoro.com/blog/wp-content/uploads/2019/08/Paid-Organic-Zero-Click-June-2019-1024x576.png" alt="2019 graph" width="700"></p>

위 조사 결과를 보면 알 수 있듯이, 40%가 오가닉 검색을 활용하고 있으며, 4.4% 유저만이 광고를 클릭하고 있습니다. 이 그래프가 절대적이다라고 할 수는 없지만, 저 또한 광고라고 표시된 사이트는 접속을 잘 하지 않고 있습니다.

이렇듯 기업에서 검색 엔진에서 노출 순위를 무시할 수 없는 이유는 노출이 많이 될 수록 마케팅 효과를 얻을 수 있기 때문입니다. 특히나 검색 엔진 최적화를 선택하면 유료 광고와 달리 집행 비용이 발생하지 않기 때문에 너무나도 큰 장점으로 다가오는 것입니다.

그렇다면 검색 엔진 최적화 어떻게 하면 되는 것일까요?
<br/><br/>

### 메타 태그(Meta Tag)

- \<title> 태그 : 검색 엔진에 검색했을 때 노출되는 제목 <br/><br/>
- \<description> 태그 : 해당 웹페이지를 설명 요약문 (평균 1-2줄)
  > 대부분의 유저가 이 description을 보고 자신이 찾고 있는 정보가 맞는지 확인 후 접속하기 때문에 최대한 반복적인 표현없이 잘 읽히도록 작성하는 것이 좋습니다.
- \<robots> 태그 : 웹페이지 별 검색 로봇의 접근 여부를 설정
  > 보통 검색 엔진에는 웹페이지를 크롤링하는 검색 로봇이 있습니다. <br/>
  > 속성을 어떻게 정의하냐에 따라 결정됩니다. <br/>
  > cf. [구글 로봇 메타 태그](https://developers.google.com/search/docs/crawling-indexing/robots-meta-tag?hl=ko) <br/><br/>
  > 크롤링이란? <br/>
  > 검색 로봇들이 웹페이지를 돌아다니며 데이터를 수집하는 행위

<br/>

- \<canonical> 태그 : 대표 URL을 설정

```html
<link rel="canonical" href="https://example.com/shop" />
```

> 구글은 다른 URL을 가지고 있는 웹페이지가 같은 내용을 담고 있으면, 페널티를 부과하게 되고 이는 웹페이지의 색인(indexing)이 불가능해지거나 저품질 콘텐츠로 평가받게 된다. 이에 한 페이지의 대표 URL을 지정함으로써, 검색 로봇이 웹페이지를 크롤링할 때 중복 URL로 인한 페널티가 적용되게 하지 않게끔 도와주는 역할을 합니다. <br/> <br/>
> 색인이란? <br/>
> 크롤링한 데이터를 기반으로 검색 결과에 표시될 수 있도록 하는 것

<br/>

- 오픈 그래프(Open Graph) 태그 : 링크를 공유할 때 어떻게 노출될지 정의

<p align="center"><img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F1hkKC%2FbtqC78M8NMg%2F6cG5iXuxXcqxpGa7cwaRx0%2Fimg.png" alt="2019 graph" width="700"></p>

> SNS에 효과적으로 공유될 수 있게 할 뿐만아니라, 해당 웹페이지가 얼마나 공유되고 있는지 판단하는 기준이 되어 검색 상위 노출을 위한 품질 평가에 영향을 주기 때문에 오픈 그래프를 잘 만드는 것도 중요하다!

<br/>

출처 | https://yozm.wishket.com/magazine/detail/1540/

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 9. TCP와 UDP의 차이점에 대해 설명해주세요.

TCP와 UDP는 TCP/IP의 전송계층에서 사용되는 프로토콜입니다. 전송계층은 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하는 계층입니다.

### TCP(Transmission Control Protocol)

TCP는 연결 지향적 프로토콜입니다. 연결 지향적 프로토콜은 클라이언트와 서버가 연결된 상태에서 데이터를 주고 받는 프로토콜을 의미합니다. 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정해 신뢰성을 보장하는 연결형 서비스입니다.
TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(데이터, 메시지, 세그먼트라는 블록 단위)을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 합니다.

#### TCP의 특징

- 연결형 서비스로 가상 회선 방식을 제공
  - 3-way handshaking 과정을 통해 연결을 설정합니다.
  - 4-way handshaking 과정을 통해 연결을 해제합니다.
- 흐름 제어(Flow control)
  - 데이터 처리의 속도를 조절하여 수신자의 버퍼 오버플로우를 방지합니다.
- 혼잡 제어(Congestion control)
  - 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지합니다.
- 높은 신뢰성 보장
  - 위의 특징들 때문에 높은 신뢰성을 보장하게 되지만 UDP보다 데이터의 전송 속도가 느립니다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식
  - 전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있습니다.
  - 점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있습니다.

##### TCP특징 정리!

가상 회선 방식을 제공한다는 것은 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말입니다. 3-way handshaking의 과정을 사용하고 데이터의 흐름 제어나 혼잡 제어와 같은 기능을 사용하기 때문에 TCP는 연결형 서비스이고 높은 신뢰성은 보장합니다. 하지만 이러한 특징들 때문에 UDP보다 패킷을 전송하는 속도는 낮아지게 됩니다. 그렇기에 TCP는 연속성보다 신뢰성 있는 전송이 중요할 때 사용하는 프로토콜로 예를 들면, 파일 전송과 같은 경우에 사용됩니다.

##### 3-way handshaking

3-way handshake를 간단히 표현하면 다음과 같습니다.

1. Client -> Server : 내 말 들려?
2. Server -> Client : 어 잘 들려! 내 말은 들려?
3. Client -> Server : 잘 들려!

<p align="center"><img src="https://github.com/lapmu/frontend-interview-handbook/assets/115691844/53bec4a8-007d-465b-bd09-e0e0b6e3afeb" width='400px'/></p>

- SYN(synchronize sequence numbers) - 연결 확인을 보내는 무작위의 숫자 값 (내 말 들려?)
- ACK(acknowledgements) - Client 혹은 Server로부터 받은 SYN에 1을 더해 SYN을 잘 받았다는 ACK (잘 들려!)

##### 4-way handshaking

4-way handshake를 간단히 표현하면 다음과 같습니다.

1. Client -> Server : 나는 다 보냈어! 이제 끊자!
2. Server -> Client : 알겠어! 잠시만~
3. Server -> Client : 나도 끊을게!
4. Client -> Server : 알겠어!

<p align="center"><img src="https://github.com/lapmu/frontend-interview-handbook/assets/115691844/8817c68b-86de-41b5-94a9-d1d5f298bc88" width='400px'/></p>

### UDP(User Datagram Protocol)

UDP는 비연결형 프로토콜입니다. 연결을 위해 할당되는 논리적인 경로가 없고, 각각의 패킷은 다른 경로로 전송되며, 독립적인 관계를 지닙니다.

<p align="center"><img src="https://github.com/lapmu/frontend-interview-handbook/assets/115691844/e409ea33-31b2-4553-a2d8-43dc428993e6" width='400px'/></p>

#### UDP의 특징

- 비연결형 서비스로 데이터그램 방식을 제공
  - 데이터의 전송 순서가 바뀔수 있습니다.
- 데이터의 수신 여부를 확인하지 않음
  - TCP의 3-way handshaking과 같은 과정을 거치지 않습니다.
- TCP보다 데이터의 전송 속도가 빠름
- 1:1, 1:다수, 다수:다수 통신이 가능

#### UDP특징 정리!

비연결 서비스이기 때문에 연결을 설정하고 해제하는 과정이 존재하지 않습니다. 패킷을 서로 다른 경로를 통해 독립적으로 처리하며 TCP처럼 흐름 제어 또는 혼잡제어와 같은 처리과정을 거치지 않기 때문에 데이터 전송 속도가 TCP보다 빠르고 네트워크의 부담이 적다는 장점이 있지만 신뢰성 있는 데이터 전송을 보장하지 못합니다. UDP는 신뢰성보다는 연속성 있는 전송이 필요할 때 사용하는 프로토콜로 예를 들면, 실시간 서비스(streaming)에 자주 사용됩니다.

## 총정리!

TCP는 패킷의 전송 순서가 보장되며 높은 신뢰도를 가지는 데이터의 전송을 보장하기 때문에 연속성보다 신뢰성이 필요한 데이터 전송을 할 경우 시용되는 프로토콜이며 UDP는 TCP보다 빠르고 네트워크 부하가 적다는 장점이 있지만 신뢰성 있는 데이터 전송을 보장하지 않기 때문에 신뢰성보다는 연속성이 중요한 실시간 스트리밍과 같은 서비스에 자주 사용합니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 10. 프레임워크와 라이브러리의 차이점에 대해 말씀해주세요.

프레임워크와 라이브러리는 누군가 만들어 놓은 기능을 가져다 사용하기 때문에 개발하는데 편리함과 도움을 준다는 공통점이 존재합니다. 프레임워크는 기본적인 기능이 구현되어 있어 개발자가 개발에만 집중할 수 있도록 도와줍니다. 라이브러리는 기능들을 함수의 단위로 만들어 제공하며 사용자는 라이브러리가 제공하는 기능을 가져다 사용하기만 하면 됩니다.

### 프레임워크와 라이브러리의 차이점

프레임워크와 라이브러리는 제어할 수 있는 권한에서 차이가 납니다. 프레임워크는 전체적인 흐름에 대해 권한이 있고 사용자가 제어할 수 없고 정해진 틀 안에서 사용해야 합니다. 하지만 라이브러리는 사용자가 직접 제어하고 기능을 어떻게 사용할 것인지 필요한 기능만 가져다 사용할 수 있습니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 11. UI와 UX에 대해 설명해 주세요.

### UI

User Interface의 약자로 사용자가 브라우저를 사용할 때 보이는 화면의 디자인, 레이아웃 등의 시각적으로 드러나는 기술적인 부분을 말합니다. 정보기기와 유저가 서로 상호 작용을 할 수 있도록 만들어주는 화면이나 아이콘, 검색창, 키보드, 문자, 색상 및 반응형 기술 등 모든 것이 포함됩니다.

### UX

User Experience의 약자로 사용하는 사용자들의 경험을 분석하여 더 편하고 효율적인 방향으로 프로세스가 진행될 수 있도록 만드는 것을 말합니다. 사용자가 어떠한 서비스, 제품을 직간접적으로 이용하며 느끼는 종합적인 만족도를 말합니다.

### UI와 UX

사용자 경험인 UX를 바탕으로 사용자의 니즈를 파악하고 이 니즈를 바탕으로 UI를 업그레이드 하면 사용자의 만족도가 높아지며 서비스에 체류하는 기간이 늘어나게 됩니다.

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>

## 12. CORS가 무엇이며, 해결하기 위한 방법에 대해 설명해 주세요.

Cross Origin Resource Sharing의 약자로, 웹 페이지가 제공하는 도메인이 아닌 다른 도메인에서 리소스를 요청하는 것을 의미합니다. 브라우저는 CORS 에러를 발생시켜 악의적인 스크립트가 중요한 데이터에 접근하거나 무단 요청하지 못하도록 방지합니다.
이를 해결하기 위해서는 프록시 서버를 설정할 수도 있고 또는 CORS 헤더를 작성하여 특정 도메인의 요청을 허용해 줄 수 있습니다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJNtN4%2FbtrP7NXIqJQ%2F6z9koCdW87EHtdt27feEt0%2Fimg.jpg" alt="" width="400px" />

cf. [CORS 해결방법](https://sisiblog.tistory.com/285)

## 13. 리플로우와 리페인트에 대해 설명해주세요.

리플로우와 리페인트는 DOM 요소의 레이아웃 수치가 변경되었을 때, 변경된 수치를 다시 계산하여 브라우저 화면을 다시 그려주는 작업입니다. 만약 DOM 요소의 레이아웃 수치가 변경되면 리플로우가 발생하여 렌더트리를 재생성하고, 재생성된 렌더트리를 기반으로 요소를 화면에 그리는 리페인트가 발생합니다.

### 리플로우(reflow)

리플로우는 DOM 요소의 기하학적 속성이 변경될때, 브라우저 사이즈가 변할때, 스타일시트가 로딩되었을때 발생하는 변화들을 다시 계산 해주는 작업을 뜻하고 렌더트리를 재생성하는 것을 말합니다.

### 리페인트(repaint)

리플로우가 일어나게되면 리페인트도 일어나게 되지만 background-color, visibillty, outline 등의 스타일 변경 시에는 레이아웃 수치가 변경되지 않으므로 리플로우 과정이 생략된 리페인트 과정만 일어나게 됩니다. 리페인트가 일어나게 되면 DOMtree의 다른 노드들의 스킨까지 검증해야 하므로 많은 리소스가 발생합니다.

### 발생 조건

- 윈도우 리사이징 (뷰포트 변화는 Global Layout에 영향)
- 폰트의 변화 (height계산에 영향을 주므로 Global Layout에 영향)
- 스타일 추가 또는 제거(레이아웃을 바꾸므로)
- 내용 변화 (인풋박스에 텍스트 입력 등..)
- :hover와 같은 CSS 의사 클래스
- 클래스 Attribute의 동적 변화
- JS를 통한 DOM 동적 변화
- 엘리먼트에 대한 offsetWidth / offsetHeight (화면에서 보여지는 좌표) 계산시
- 스타일 Attribute 동적변화
  등등...(더욱 자세한 사항은 [이곳으로](https://gist.github.com/paulirish/5d52fb081b3570c81e3a))

### 최적화

- 클래스 변화에 따른 스타일 변화를 원할 경우, 최대한 DOM 구조 상 끝단에 위치한 노드에 주어라. (DOM 구조 상 끝단에 위치한 노드에서 리플로우가 일어날 경우 전체 페이지가 아닌 일부 페이지에서 리플로우가 일어나기 때문에 리플로우의 영향을 최소화함으로써 리소스의 사용을 줄일 수 있습니다.)
- 인라인 스타일을 최대한 배제하라. (인라인상에 스타일이 주어진 경우, 리플로우는 페이지 전체에 걸쳐 수차례 발생하게 됩니다. 만일 인라인스타일이 없을 경우, 외부스타일 클래스의 조합으로 단 한번만 리플로우를 발생 시킵니다)
- 애니메이션이 들어간 엘리먼트는 가급적 position:fixed 또는 position:absolute 로 지정 (CSS로 width/height 또는 위치이동을 구현한 애니메이션은 거의 초단위로 상당한 Reflow를 불러 일으킵니다. 이러한 경우에 해당 개체의 position 속성을 fixed 또는 absoute로 주게 되면 다른 요소들의 레이아웃에 영향을 끼치지 않으므로 페이지 전체의 Reflow 대신 해당 애니메이션 요소의 Repaint만을 유발합니다.)
- 테이블 레이아웃을 피하라. (테이블 레이아웃에서는 아주 작은 변화마저도 해당 테이블 전체 모든 노드에 대한 Reflow를 발생시킵니다.)
- IE의 경우, CSS에서의 JS표현식을 피하라. (문서 전체 또는 문서 중 일부가 리플로우 될 때마다 표현식이 다시 계산되기 때문에 CSS표현식은 반드시 피해야 합니다.)
- JS를 통해 스타일변화를 주어야 할 경우, 가급적 한번에 처리하라.

```javascript

let toChange = document.getElementById('elem');
toChange.style.background = '#333';
toChange.style.color = '#fff';
toChange.style.border = '1px solid #ccc';

// CSS
#elem { border:1px solid #000; color:#000; background:#ddd; }
.highlight { border-color:#00f; color:#fff; background:#333; }

// js
document.getElementById('elem').className = 'highlight';

```

<br/><br/>
👆 [맨 위로 올라가기](https://github.com/sienna0715/frontend-interview-handbook/tree/main/React#react)
<br/><br/>
